#pragma config(Motor,  port1,           WheelLB,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           WheelRF,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           WheelRB,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ArmRT,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ArmRB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           ArmLT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ArmLB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ClawL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ClawR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          WheelLF,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"



void pre_auton()
{

}

void go_robit(int a, int b, int c) {
motor[WheelRB] = motor[WheelRF] = b; // Allows you to set each side for turning. This gives you more accessibility.
motor[WheelLB] = motor[WheelLF] = c;
wait1Msec(a);
}

void go_arm(int a, int b, int c) {
motor[ArmRT] = motor[ArmRB] = b;
motor[ArmLT] = motor[ArmLB] = c;
wait1Msec(a);
}

void go_claw(int a, int b) {
motor[ClawL] = motor[ClawR] =	b;
wait1Msec(a);
}

task autonomous() {
go_robit(2000, 127, 127); //Pushes pre-loaded star under the fence
go_robit(500, 0, 0,); // Stops robit
go_robit(500, -127, -127); // Robit goes back
go_robit(500, 0, 0); // Stops robit
go_arm(750, 127, 127); // Arm up
go_arm(500, 0, 0); // Arm stops
go_claw(750, 127); // Claw opens
go_claw(500, 0); // Claw stopsddd
go_robit(500, 127, -127); // Turn towards cube
go_robit(500, 0, 0); // Stops robit
go_robit(750, 127, 127); // Robit moves forward to cube
go_robit(500, 0, 0); //
go_claw(500, 127);
go_claw(500, 0);

}

task usercontrol() {
while(1==1) {
motor[WheelLF] = motor[WheelLB] = vexRT[Ch2] + vexRT[Ch1];
motor[WheelRF] = motor[WheelRB] = vexRT[Ch2] - vexRT[Ch1];

if(vexRT[Btn5U]){ //Arm
	motor[ArmLB] = motor[ArmLT] = motor[ArmRT] = motor[ArmRB] = 127;
}
else if(vexRT[Btn5D]){
	motor[ArmLB] = motor[ArmLT] = motor[ArmRT] = motor[ArmRB] = -127;
}
else{
	motor[ArmLB] = motor[ArmLT] = motor[ArmRT] = motor[ArmRB] = 0;
}

if(vexRT[Btn6U]){ //Claw;
	motor[ClawL] = motor[ClawR] = 127;
}
else if(vexRT[Btn6D]){
	motor[ClawL] = motor[ClawR] = -127;
}
else
	motor[ClawL] = motor[ClawR] = 0;
} //While loop close }

} //Task usercontol close }
void allMotorsOff(){ }
void allTasksStop(){ }
